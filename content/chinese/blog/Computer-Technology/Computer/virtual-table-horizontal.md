---
title: 原生表格的虚拟滚动实践（下）
date: 2024-12-16T08:44:18.020Z
update: 2024-12-16T08:44:18.694Z
author: LeeZChuan
categories:
    - 计算机技术
    - 虚拟滚动
description: 由于业务开发需要在低版本浏览器中使用，所以需要使用原生表格实现虚拟滚动，本篇分享表格横向的虚拟滚动。
---


## 前言

本篇文章分享如何实现横向的虚拟滚动。

## 原生表格的横向虚拟滚动

### 原生表格-横向

> 在原文中提到这个方案：

横向虚拟滚动
当表格的列非常多时，也会导致表格渲染卡顿，所以如何在原生组件下实现了横向的虚拟滚动。横向虚拟滚动的开启前提是所有列的宽度都已知，这使横向的实现更加直截了当。根据当前的偏移量和最大渲染宽度，就可以精确地算出渲染范围，不再需要缓存来记录每一列的实际/预估宽度了。

{{< image src="images/blog/virtual03.png" caption="" alt="" height="" width="" position="center" command="fill"  class="img-fluid" title="实现3"  webp="false" >}}


不过左右两侧锁列的存在给实现带来了一定的麻烦：锁定的列不需要进行虚拟滚动。为了使横向虚拟滚动与锁列兼容，组件将所有列分为五个部分，从左至右依次为：left-lock, left-blank, center, right-blank, right-lock。根据 offset / maxRenderWidth 计算渲染范围时，组件要先根据锁列部分对输入进行调整，从而计算出非锁列部分的渲染范围（即算出 center 部分对应的下标）。在实际渲染时，组件会用一个宽度很大的单元格来替代 left-blank 所对应的多个单元格（right-blank 同理）。

表头包含嵌套结构（一个父节点下可以放置多个子节点），故其横向虚拟滚动实现会更加麻烦一些。因为父节点并不对应实际的表格列，横向虚拟滚动只与叶子节点相关。在计算得到横向的渲染范围之后，组件会根据「所需要渲染的叶子节点的列表」计算出「需要渲染的父节点的列表」，同样的，计算过程中要特别注意锁列带来的影响。


横向滚动时，td 单元格数量可能不断发生变化，相应的父节点的 colSpan 也会不断发生变化，使得单元格的宽度变化较大。当单元格宽度变小时，内容较多的表头的单元格高度会自动增大，导致整个表头行变高；继续滚动，单元格因为虚拟滚动而不再渲染，整个表头行又会突然变回原值，使得横向滚动时表头高度不断抖动。

:::TIP
因为表头默认开启了吸顶，表头大部分情况下会固定在页面顶部，此类抖动的视觉效果非常明显。所以 ali-react-table 默认关闭了表头的虚拟滚动，避免此类抖动；而纵向虚拟滚动会在表格超过 100 行时自动开启，横向虚拟滚动会在 100 列以上时自动开启。
:::

### 虚拟滚动中的「过扫描」

> 在某些电视机中，过扫描是一种行为，其中输入图片的一部分显示在屏幕的可视范围之外。之所以存在，是因为1930年代到2000年代初期的阴极射线管电视机在视频图像在屏幕边界内的定位方式上存在很大差异。后来，在图像周围出现黑色边缘的视频信号已成为惯例，电视本应以这种方式将其丢弃。


在虚拟滚动场景下，我们也需要 overscan —— 表格单元格的渲染范围不仅要充满可视区域，还要向可视区域四周延伸一定的距离。overscan 有以下优势：
● 焦点切换：按下Tab 键时，焦点可以被切换到表格下方部分，触发表格滚动使得表格渲染更多行或列
● 减少重渲染频率：滚动距离较小时，可以确保上一次的渲染内容仍会充满可视区域，不需要再触发 re-render
● 减少白屏时间：缓慢滚动的时候，部分元素已经提前渲染好了，减少白屏时间

{{< image src="images/blog/overscan.png" caption="" alt="" height="" width="" position="center" command="fill"  class="img-fluid" title="overscan"  webp="false" >}}


## 参考

1. https://www.yuque.com/shinima/blog/nbgglx
2. https://www.yuque.com/shinima/blog/llo9ro


