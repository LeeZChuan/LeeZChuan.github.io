---
title: 原生表格的虚拟滚动实践（下）
date: 2024-12-16T08:44:18.020Z
update: 2024-12-16T08:44:18.694Z
author: LeeZChuan
categories:
    - 计算机技术
    - 虚拟滚动
description: 由于业务开发需要在低版本浏览器中使用，所以需要使用原生表格实现虚拟滚动，本篇分享表格横向的虚拟滚动。
---


## 前言

在前端开发中，表格一直都是最复杂的组件之一，由于公司业务，需要在低版本浏览器中使用，并且需要实现固定列，所以市面上使用（使用position:sticky 实现粘性布局）的方案就被pass掉了，因为该特性只能在浏览器56版本以上才能使用，需要使用原生表格实现虚拟滚动，本篇仅分享表格竖向的虚拟滚动。

## 原生表格的横向虚拟滚动

### 原生表格-横向

> 在原文中提到这个方案：

横向虚拟滚动
当表格的列非常多时，也会导致表格渲染卡顿，所以 ali-react-table 在实现了横向的虚拟滚动。横向虚拟滚动的开启前提是所有列的宽度都已知，这使横向的实现更加直截了当。根据当前的偏移量和最大渲染宽度，就可以精确地算出渲染范围，不再需要缓存来记录每一列的实际/预估宽度了。

{{< image src="images/virtual03.png" caption="" alt="" height="" width="" position="center" command="fill"  class="img-fluid" title="实现3"  webp="false" >}}


不过左右两侧锁列的存在给实现带来了一定的麻烦：锁定的列不需要进行虚拟滚动。为了使横向虚拟滚动与锁列兼容，组件将所有列分为五个部分，从左至右依次为：left-lock, left-blank, center, right-blank, right-lock。根据 offset / maxRenderWidth 计算渲染范围时，组件要先根据锁列部分对输入进行调整，从而计算出非锁列部分的渲染范围（即算出 center 部分对应的下标）。在实际渲染时，组件会用一个宽度很大的单元格来替代 left-blank 所对应的多个单元格（right-blank 同理）。

表头包含嵌套结构（一个父节点下可以放置多个子节点），故其横向虚拟滚动实现会更加麻烦一些。因为父节点并不对应实际的表格列，横向虚拟滚动只与叶子节点相关。在计算得到横向的渲染范围之后，组件会根据「所需要渲染的叶子节点的列表」计算出「需要渲染的父节点的列表」，同样的，计算过程中要特别注意锁列带来的影响。


横向滚动时，td 单元格数量可能不断发生变化，相应的父节点的 colSpan 也会不断发生变化，使得单元格的宽度变化较大。当单元格宽度变小时，内容较多的表头的单元格高度会自动增大，导致整个表头行变高；继续滚动，单元格因为虚拟滚动而不再渲染，整个表头行又会突然变回原值，使得横向滚动时表头高度不断抖动。

:::TIP
因为表头默认开启了吸顶，表头大部分情况下会固定在页面顶部，此类抖动的视觉效果非常明显。所以 ali-react-table 默认关闭了表头的虚拟滚动，避免此类抖动；而纵向虚拟滚动会在表格超过 100 行时自动开启，横向虚拟滚动会在 100 列以上时自动开启。
:::

## 参考

1. https://www.yuque.com/shinima/blog/nbgglx
2. https://www.yuque.com/shinima/blog/llo9ro


